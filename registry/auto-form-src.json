{
  "name": "AutoForm",
  "type": "registry:ui",
  "registryDependencies": [
    "accordion",
    "button",
    "calendar",
    "card",
    "checkbox",
    "form",
    "input",
    "label",
    "popover",
    "radio-group",
    "select",
    "separator",
    "switch",
    "textarea",
    "tooltip",
    "toggle"
  ],
  "dependencies": [
    "zod"
  ],
  "devDependencies": [],
  "tailwind": {
    "config": {}
  },
  "cssVars": {},
  "files": [
    {
      "path": "utils.ts",
      "target": "src/components/ui/auto-form/utils.ts",
      "content": "import React from \"react\";\nimport { DefaultValues } from \"react-hook-form\";\nimport { z } from \"zod\";\nimport { FieldConfig } from \"./types\";\n\n// TODO: This should support recursive ZodEffects but TypeScript doesn't allow circular type definitions.\nexport type ZodObjectOrWrapped =\n  | z.ZodObject<any, any>\n  | z.ZodEffects<z.ZodObject<any, any>>;\n\n/**\n * Beautify a camelCase string.\n * e.g. \"myString\" -> \"My String\"\n */\nexport function beautifyObjectName(string: string) {\n  // if numbers only return the string\n  let output = string.replace(/([A-Z])/g, \" $1\");\n  output = output.charAt(0).toUpperCase() + output.slice(1);\n  return output;\n}\n\n/**\n * Get the lowest level Zod type.\n * This will unpack optionals, refinements, etc.\n */\nexport function getBaseSchema<\n  ChildType extends z.ZodAny | z.AnyZodObject = z.ZodAny,\n>(schema: ChildType | z.ZodEffects<ChildType>): ChildType | null {\n  if (!schema) return null;\n  if (\"innerType\" in schema._def) {\n    return getBaseSchema(schema._def.innerType as ChildType);\n  }\n  if (\"schema\" in schema._def) {\n    return getBaseSchema(schema._def.schema as ChildType);\n  }\n\n  return schema as ChildType;\n}\n\n/**\n * Get the type name of the lowest level Zod type.\n * This will unpack optionals, refinements, etc.\n */\nexport function getBaseType(schema: z.ZodAny): string {\n  const baseSchema = getBaseSchema(schema);\n  return baseSchema ? baseSchema._def.typeName : \"\";\n}\n\n/**\n * Search for a \"ZodDefult\" in the Zod stack and return its value.\n */\nexport function getDefaultValueInZodStack(schema: z.ZodAny): any {\n  const typedSchema = schema as unknown as z.ZodDefault<\n    z.ZodNumber | z.ZodString\n  >;\n\n  if (typedSchema._def.typeName === \"ZodDefault\") {\n    return typedSchema._def.defaultValue();\n  }\n\n  if (\"innerType\" in typedSchema._def) {\n    return getDefaultValueInZodStack(\n      typedSchema._def.innerType as unknown as z.ZodAny,\n    );\n  }\n  if (\"schema\" in typedSchema._def) {\n    return getDefaultValueInZodStack(\n      (typedSchema._def as any).schema as z.ZodAny,\n    );\n  }\n\n  return undefined;\n}\n\n/**\n * Get all default values from a Zod schema.\n */\nexport function getDefaultValues<Schema extends z.ZodObject<any, any>>(\n  schema: Schema,\n  fieldConfig?: FieldConfig<z.infer<Schema>>,\n) {\n  if (!schema) return null;\n  const { shape } = schema;\n  type DefaultValuesType = DefaultValues<Partial<z.infer<Schema>>>;\n  const defaultValues = {} as DefaultValuesType;\n  if (!shape) return defaultValues;\n\n  for (const key of Object.keys(shape)) {\n    const item = shape[key] as z.ZodAny;\n\n    if (getBaseType(item) === \"ZodObject\") {\n      const defaultItems = getDefaultValues(\n        getBaseSchema(item) as unknown as z.ZodObject<any, any>,\n        fieldConfig?.[key] as FieldConfig<z.infer<Schema>>,\n      );\n\n      if (defaultItems !== null) {\n        for (const defaultItemKey of Object.keys(defaultItems)) {\n          const pathKey = `${key}.${defaultItemKey}` as keyof DefaultValuesType;\n          defaultValues[pathKey] = defaultItems[defaultItemKey];\n        }\n      }\n    } else {\n      let defaultValue = getDefaultValueInZodStack(item);\n      if (\n        (defaultValue === null || defaultValue === \"\") &&\n        fieldConfig?.[key]?.inputProps\n      ) {\n        defaultValue = (fieldConfig?.[key]?.inputProps as unknown as any)\n          .defaultValue;\n      }\n      if (defaultValue !== undefined) {\n        defaultValues[key as keyof DefaultValuesType] = defaultValue;\n      }\n    }\n  }\n\n  return defaultValues;\n}\n\nexport function getObjectFormSchema(\n  schema: ZodObjectOrWrapped,\n): z.ZodObject<any, any> {\n  if (schema?._def.typeName === \"ZodEffects\") {\n    const typedSchema = schema as z.ZodEffects<z.ZodObject<any, any>>;\n    return getObjectFormSchema(typedSchema._def.schema);\n  }\n  return schema as z.ZodObject<any, any>;\n}\n\n/**\n * Convert a Zod schema to HTML input props to give direct feedback to the user.\n * Once submitted, the schema will be validated completely.\n */\nexport function zodToHtmlInputProps(\n  schema:\n    | z.ZodNumber\n    | z.ZodString\n    | z.ZodOptional<z.ZodNumber | z.ZodString>\n    | any,\n): React.InputHTMLAttributes<HTMLInputElement> {\n  if ([\"ZodOptional\", \"ZodNullable\"].includes(schema._def.typeName)) {\n    const typedSchema = schema as z.ZodOptional<z.ZodNumber | z.ZodString>;\n    return {\n      ...zodToHtmlInputProps(typedSchema._def.innerType),\n      required: false,\n    };\n  }\n  const typedSchema = schema as z.ZodNumber | z.ZodString;\n\n  if (!(\"checks\" in typedSchema._def))\n    return {\n      required: true,\n    };\n\n  const { checks } = typedSchema._def;\n  const inputProps: React.InputHTMLAttributes<HTMLInputElement> = {\n    required: true,\n  };\n  const type = getBaseType(schema);\n\n  for (const check of checks) {\n    if (check.kind === \"min\") {\n      if (type === \"ZodString\") {\n        inputProps.minLength = check.value;\n      } else {\n        inputProps.min = check.value;\n      }\n    }\n    if (check.kind === \"max\") {\n      if (type === \"ZodString\") {\n        inputProps.maxLength = check.value;\n      } else {\n        inputProps.max = check.value;\n      }\n    }\n  }\n\n  return inputProps;\n}\n\n/**\n * Sort the fields by order.\n * If no order is set, the field will be sorted based on the order in the schema.\n */\n\nexport function sortFieldsByOrder<SchemaType extends z.ZodObject<any, any>>(\n  fieldConfig: FieldConfig<z.infer<SchemaType>> | undefined,\n  keys: string[]\n) {\n  const sortedFields = keys.sort((a, b) => {\n    const fieldA: number = (fieldConfig?.[a]?.order as number) ?? 0;\n    const fieldB = (fieldConfig?.[b]?.order as number) ?? 0;\n    return fieldA - fieldB;\n  });\n\n  return sortedFields;\n}",
      "type": "registry:ui"
    },
    {
      "path": "types.ts",
      "target": "src/components/ui/auto-form/types.ts",
      "content": "import { ControllerRenderProps, FieldValues } from \"react-hook-form\";\nimport * as z from \"zod\";\nimport { INPUT_COMPONENTS } from \"./config\";\n\nexport type FieldConfigItem = {\n  description?: React.ReactNode;\n  inputProps?: React.InputHTMLAttributes<HTMLInputElement> &\n    React.TextareaHTMLAttributes<HTMLTextAreaElement> & {\n      showLabel?: boolean;\n    };\n  label?: string;\n  fieldType?:\n    | keyof typeof INPUT_COMPONENTS\n    | React.FC<AutoFormInputComponentProps>;\n\n  renderParent?: (props: {\n    children: React.ReactNode;\n  }) => React.ReactElement | null;\n\n  order?: number;\n};\n\nexport type FieldConfig<SchemaType extends z.infer<z.ZodObject<any, any>>> = {\n  // If SchemaType.key is an object, create a nested FieldConfig, otherwise FieldConfigItem\n  [Key in keyof SchemaType]?: SchemaType[Key] extends object\n    ? FieldConfig<z.infer<SchemaType[Key]>>\n    : FieldConfigItem;\n};\n\nexport enum DependencyType {\n  DISABLES,\n  REQUIRES,\n  HIDES,\n  SETS_OPTIONS,\n}\n\ntype BaseDependency<SchemaType extends z.infer<z.ZodObject<any, any>>> = {\n  sourceField: keyof SchemaType;\n  type: DependencyType;\n  targetField: keyof SchemaType;\n  when: (sourceFieldValue: any, targetFieldValue: any) => boolean;\n};\n\nexport type ValueDependency<SchemaType extends z.infer<z.ZodObject<any, any>>> =\n  BaseDependency<SchemaType> & {\n    type:\n      | DependencyType.DISABLES\n      | DependencyType.REQUIRES\n      | DependencyType.HIDES;\n  };\n\nexport type EnumValues = readonly [string, ...string[]];\n\nexport type OptionsDependency<\n  SchemaType extends z.infer<z.ZodObject<any, any>>,\n> = BaseDependency<SchemaType> & {\n  type: DependencyType.SETS_OPTIONS;\n\n  // Partial array of values from sourceField that will trigger the dependency\n  options: EnumValues;\n};\n\nexport type Dependency<SchemaType extends z.infer<z.ZodObject<any, any>>> =\n  | ValueDependency<SchemaType>\n  | OptionsDependency<SchemaType>;\n\n/**\n * A FormInput component can handle a specific Zod type (e.g. \"ZodBoolean\")\n */\nexport type AutoFormInputComponentProps = {\n  zodInputProps: React.InputHTMLAttributes<HTMLInputElement>;\n  field: ControllerRenderProps<FieldValues, any>;\n  fieldConfigItem: FieldConfigItem;\n  label: string;\n  isRequired: boolean;\n  fieldProps: any;\n  zodItem: z.ZodAny;\n  className?: string;\n};\n",
      "type": "registry:ui"
    },
    {
      "path": "index.tsx",
      "target": "src/components/ui/auto-form/index.tsx",
      "content": "\"use client\";\nimport { Form } from \"@/components/ui/form\";\nimport React from \"react\";\nimport {\n  DefaultValues,\n  FormState,\n  useForm,\n  UseFormReturn,\n} from \"react-hook-form\";\nimport { z } from \"zod\";\n\nimport { Button } from \"@/components/ui/button\";\nimport { cn } from \"@/lib/utils\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\n\nimport AutoFormObject from \"./fields/object\";\nimport { Dependency, FieldConfig } from \"./types\";\nimport {\n  getDefaultValues,\n  getObjectFormSchema,\n  ZodObjectOrWrapped,\n} from \"./utils\";\n\nexport function AutoFormSubmit({\n  children,\n  className,\n  disabled,\n}: {\n  children?: React.ReactNode;\n  className?: string;\n  disabled?: boolean;\n}) {\n  return (\n    <Button type=\"submit\" disabled={disabled} className={className}>\n      {children ?? \"Submit\"}\n    </Button>\n  );\n}\n\nfunction AutoForm<SchemaType extends ZodObjectOrWrapped>({\n  formSchema,\n  values: valuesProp,\n  onValuesChange: onValuesChangeProp,\n  onParsedValuesChange,\n  onSubmit: onSubmitProp,\n  fieldConfig,\n  children,\n  className,\n  dependencies,\n}: {\n  formSchema: SchemaType;\n  values?: Partial<z.infer<SchemaType>>;\n  onValuesChange?: (\n    values: Partial<z.infer<SchemaType>>,\n    form: UseFormReturn<z.infer<SchemaType>>\n  ) => void;\n  onParsedValuesChange?: (\n    values: Partial<z.infer<SchemaType>>,\n    form: UseFormReturn<z.infer<SchemaType>>\n  ) => void;\n  onSubmit?: (\n    values: z.infer<SchemaType>,\n    form: UseFormReturn<z.infer<SchemaType>>\n  ) => void;\n  fieldConfig?: FieldConfig<z.infer<SchemaType>>;\n  children?:\n    | React.ReactNode\n    | ((formState: FormState<z.infer<SchemaType>>) => React.ReactNode);\n  className?: string;\n  dependencies?: Dependency<z.infer<SchemaType>>[];\n}) {\n  const objectFormSchema = getObjectFormSchema(formSchema);\n  const defaultValues: DefaultValues<z.infer<typeof objectFormSchema>> | null =\n    getDefaultValues(objectFormSchema, fieldConfig);\n\n  const form = useForm<z.infer<typeof objectFormSchema>>({\n    resolver: zodResolver(formSchema),\n    defaultValues: defaultValues ?? undefined,\n    values: valuesProp,\n  });\n\n  function onSubmit(values: z.infer<typeof formSchema>) {\n    const parsedValues = formSchema.safeParse(values);\n    if (parsedValues.success) {\n      onSubmitProp?.(parsedValues.data, form);\n    }\n  }\n\n  React.useEffect(() => {\n    const subscription = form.watch((values) => {\n      onValuesChangeProp?.(values, form);\n      const parsedValues = formSchema.safeParse(values);\n      if (parsedValues.success) {\n        onParsedValuesChange?.(parsedValues.data, form);\n      }\n    });\n\n    return () => subscription.unsubscribe();\n  }, [form, formSchema, onValuesChangeProp, onParsedValuesChange]);\n\n  const renderChildren =\n    typeof children === \"function\"\n      ? children(form.formState as FormState<z.infer<SchemaType>>)\n      : children;\n\n  return (\n    <div className=\"w-full\">\n      <Form {...form}>\n        <form\n          onSubmit={(e) => {\n            form.handleSubmit(onSubmit)(e);\n          }}\n          className={cn(\"space-y-5\", className)}\n        >\n          <AutoFormObject\n            schema={objectFormSchema}\n            form={form}\n            dependencies={dependencies}\n            fieldConfig={fieldConfig}\n          />\n\n          {renderChildren}\n        </form>\n      </Form>\n    </div>\n  );\n}\n\nexport default AutoForm;\n",
      "type": "registry:ui"
    },
    {
      "path": "dependencies.ts",
      "target": "src/components/ui/auto-form/dependencies.ts",
      "content": "import { FieldValues, UseFormWatch } from \"react-hook-form\";\nimport { Dependency, DependencyType, EnumValues } from \"./types\";\nimport * as z from \"zod\";\n\nexport default function resolveDependencies<\n  SchemaType extends z.infer<z.ZodObject<any, any>>,\n>(\n  dependencies: Dependency<SchemaType>[],\n  currentFieldName: keyof SchemaType,\n  watch: UseFormWatch<FieldValues>,\n) {\n  let isDisabled = false;\n  let isHidden = false;\n  let isRequired = false;\n  let overrideOptions: EnumValues | undefined;\n\n  const currentFieldValue = watch(currentFieldName as string);\n\n  const currentFieldDependencies = dependencies.filter(\n    (dependency) => dependency.targetField === currentFieldName,\n  );\n  for (const dependency of currentFieldDependencies) {\n    const watchedValue = watch(dependency.sourceField as string);\n\n    const conditionMet = dependency.when(watchedValue, currentFieldValue);\n\n    switch (dependency.type) {\n      case DependencyType.DISABLES:\n        if (conditionMet) {\n          isDisabled = true;\n        }\n        break;\n      case DependencyType.REQUIRES:\n        if (conditionMet) {\n          isRequired = true;\n        }\n        break;\n      case DependencyType.HIDES:\n        if (conditionMet) {\n          isHidden = true;\n        }\n        break;\n      case DependencyType.SETS_OPTIONS:\n        if (conditionMet) {\n          overrideOptions = dependency.options;\n        }\n        break;\n    }\n  }\n\n  return {\n    isDisabled,\n    isHidden,\n    isRequired,\n    overrideOptions,\n  };\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "config.ts",
      "target": "src/components/ui/auto-form/config.ts",
      "content": "import AutoFormCheckbox from \"./fields/checkbox\";\nimport AutoFormDate from \"./fields/date\";\nimport AutoFormEnum from \"./fields/enum\";\nimport AutoFormFile from \"./fields/file\";\nimport AutoFormInput from \"./fields/input\";\nimport AutoFormNumber from \"./fields/number\";\nimport AutoFormRadioGroup from \"./fields/radio-group\";\nimport AutoFormSwitch from \"./fields/switch\";\nimport AutoFormTextarea from \"./fields/textarea\";\n\nexport const INPUT_COMPONENTS = {\n  checkbox: AutoFormCheckbox,\n  date: AutoFormDate,\n  select: AutoFormEnum,\n  radio: AutoFormRadioGroup,\n  switch: AutoFormSwitch,\n  textarea: AutoFormTextarea,\n  number: AutoFormNumber,\n  file: AutoFormFile,\n  fallback: AutoFormInput,\n};\n\n/**\n * Define handlers for specific Zod types.\n * You can expand this object to support more types.\n */\nexport const DEFAULT_ZOD_HANDLERS: {\n  [key: string]: keyof typeof INPUT_COMPONENTS;\n} = {\n  ZodBoolean: \"checkbox\",\n  ZodDate: \"date\",\n  ZodEnum: \"select\",\n  ZodNativeEnum: \"select\",\n  ZodNumber: \"number\",\n};\n",
      "type": "registry:ui"
    },
    {
      "path": "tests/basics.cy.tsx",
      "target": "src/components/ui/auto-form/tests/basics.cy.tsx",
      "content": "import { z } from \"zod\";\nimport AutoForm from \"../index\";\n\ndescribe(\"<AutoForm />\", () => {\n  it(\"renders fields\", () => {\n    const formSchema = z.object({\n      username: z.string().min(2, {\n        message: \"Username must be at least 2 characters.\",\n      }),\n\n      password: z.string().describe(\"Your secure password\").min(8, {\n        message: \"Password must be at least 8 characters.\",\n      }),\n    });\n\n    cy.mount(<AutoForm formSchema={formSchema} />);\n    cy.get(\"input[name=username]\").should(\"exist\");\n    cy.get(\"input[name=password]\").should(\"exist\");\n  });\n\n  it(\"renders fields with custom labels\", () => {\n    const formSchema = z.object({\n      username: z.string().describe(\"Your username\"),\n    });\n\n    cy.mount(<AutoForm formSchema={formSchema} />);\n\n    cy.get(\"label\").contains(\"Your username\");\n  });\n\n  it(\"generates default labels\", () => {\n    const formSchema = z.object({\n      someFieldName: z.string(),\n    });\n\n    cy.mount(<AutoForm formSchema={formSchema} />);\n\n    cy.get(\"label\").contains(\"Some Field Name\");\n  });\n\n  it(\"allows setting custom field labels\", () => {\n    const formSchema = z.object({\n      someFieldName: z.string(),\n    });\n\n    cy.mount(\n      <AutoForm\n        fieldConfig={{\n          someFieldName: {\n            label: \"My field name\",\n          },\n        }}\n        formSchema={formSchema}\n      />,\n    );\n\n    cy.get(\"label\").contains(\"My field name\");\n  });\n\n  it(\"allows setting custom field props\", () => {\n    const formSchema = z.object({\n      username: z.string(),\n    });\n\n    cy.mount(\n      <AutoForm\n        formSchema={formSchema}\n        fieldConfig={{\n          username: {\n            inputProps: {\n              placeholder: \"Enter your username\",\n            },\n          },\n        }}\n      />,\n    );\n\n    cy.get(\"input[name=username]\").should(\n      \"have.attr\",\n      \"placeholder\",\n      \"Enter your username\",\n    );\n  });\n\n  it(\"allows setting custom field type\", () => {\n    const formSchema = z.object({\n      username: z.string(),\n    });\n\n    cy.mount(\n      <AutoForm\n        formSchema={formSchema}\n        fieldConfig={{\n          username: {\n            fieldType: \"number\",\n          },\n        }}\n      />,\n    );\n\n    cy.get(\"input\").should(\"have.attr\", \"type\", \"number\");\n  });\n\n  it(\"can submit valid forms\", () => {\n    const formSchema = z.object({\n      username: z.string(),\n    });\n\n    cy.mount(\n      <AutoForm\n        formSchema={formSchema}\n        onSubmit={(values) => {\n          expect(values).to.deep.equal({\n            username: \"john\",\n          });\n        }}\n      >\n        <button type=\"submit\">Submit</button>\n      </AutoForm>,\n    );\n\n    cy.get(\"input[name=username]\").type(\"john\");\n    cy.get(\"button[type=submit]\").click();\n  });\n\n  it(\"shows error for invalid forms\", () => {\n    const formSchema = z.object({\n      username: z.string(),\n    });\n\n    cy.mount(\n      <AutoForm\n        formSchema={formSchema}\n        onSubmit={() => {\n          expect.fail(\"Should not be called.\");\n        }}\n      >\n        <button type=\"submit\">Submit</button>\n      </AutoForm>,\n    );\n\n    cy.get(\"button[type=submit]\").click();\n  });\n\n  it(\"can set default values\", () => {\n    const formSchema = z.object({\n      username: z.string().default(\"john\"),\n    });\n\n    cy.mount(<AutoForm formSchema={formSchema} />);\n\n    cy.get(\"input[name=username]\").should(\"have.value\", \"john\");\n  });\n\n  it(\"can submit with default values\", () => {\n    const formSchema = z.object({\n      username: z.string().default(\"john\"),\n    });\n\n    cy.mount(\n      <AutoForm\n        formSchema={formSchema}\n        onSubmit={(values) => {\n          expect(values).to.deep.equal({\n            username: \"john\",\n          });\n        }}\n      >\n        <button type=\"submit\">Submit</button>\n      </AutoForm>,\n    );\n\n    cy.get(\"button[type=submit]\").click();\n  });\n\n  it(\"can set and submit optional values\", () => {\n    const formSchema = z.object({\n      username: z.string().optional(),\n    });\n\n    cy.mount(\n      <AutoForm\n        formSchema={formSchema}\n        onSubmit={(values) => {\n          expect(values).to.deep.equal({\n            username: undefined,\n          });\n        }}\n      >\n        <button type=\"submit\">Submit</button>\n      </AutoForm>,\n    );\n\n    cy.get(\"input[name=username]\").should(\"have.value\", \"\");\n    cy.get(\"button[type=submit]\").click();\n  });\n\n  it(\"can add description\", () => {\n    const formSchema = z.object({\n      username: z.string(),\n    });\n\n    cy.mount(\n      <AutoForm\n        formSchema={formSchema}\n        fieldConfig={{\n          username: {\n            description: \"Your username here\",\n          },\n        }}\n      />,\n    );\n\n    cy.get(\"p\").contains(\"Your username here\");\n  });\n\n  it(\"can set default values on array\", () => {\n    const formSchema = z.object({\n      arr: z.array(z.object({ name: z.string(), age: z.number() })).default([\n        { name: \"Haykal\", age: 21 },\n        { name: \"John\", age: 20 },\n      ]),\n    });\n\n    cy.mount(<AutoForm formSchema={formSchema} />);\n\n    //get button with text Arr\n    cy.get(\"button\").contains(\"Arr\").click();\n    cy.get(\"input[name='arr.0.name']\").should(\"have.value\", \"Haykal\");\n    cy.get(\"input[name='arr.0.age']\").should(\"have.value\", \"21\");\n    cy.get(\"input[name='arr.1.name']\").should(\"have.value\", \"John\");\n    cy.get(\"input[name='arr.1.age']\").should(\"have.value\", \"20\");\n  });\n\n  it(\"can set default value of number to 0\", () => {\n    const formSchema = z.object({\n      number: z.number().default(0),\n    });\n\n    cy.mount(<AutoForm formSchema={formSchema} />);\n\n    cy.get(\"input[name='number']\").should(\"have.value\", \"0\");\n  });\n});\n",
      "type": "registry:ui"
    },
    {
      "path": "fields/textarea.tsx",
      "target": "src/components/ui/auto-form/fields/textarea.tsx",
      "content": "import { FormControl, FormItem, FormMessage } from \"@/components/ui/form\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport AutoFormLabel from \"../common/label\";\nimport AutoFormTooltip from \"../common/tooltip\";\nimport { AutoFormInputComponentProps } from \"../types\";\n\nexport default function AutoFormTextarea({\n  label,\n  isRequired,\n  fieldConfigItem,\n  fieldProps,\n}: AutoFormInputComponentProps) {\n  const { showLabel: _showLabel, ...fieldPropsWithoutShowLabel } = fieldProps;\n  const showLabel = _showLabel === undefined ? true : _showLabel;\n  return (\n    <FormItem>\n      {showLabel && (\n        <AutoFormLabel\n          label={fieldConfigItem?.label || label}\n          isRequired={isRequired}\n        />\n      )}\n      <FormControl>\n        <Textarea {...fieldPropsWithoutShowLabel} />\n      </FormControl>\n      <AutoFormTooltip fieldConfigItem={fieldConfigItem} />\n      <FormMessage />\n    </FormItem>\n  );\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "fields/switch.tsx",
      "target": "src/components/ui/auto-form/fields/switch.tsx",
      "content": "import { FormControl, FormItem } from \"@/components/ui/form\";\nimport { Switch } from \"@/components/ui/switch\";\nimport AutoFormLabel from \"../common/label\";\nimport AutoFormTooltip from \"../common/tooltip\";\nimport { AutoFormInputComponentProps } from \"../types\";\n\nexport default function AutoFormSwitch({\n  label,\n  isRequired,\n  field,\n  fieldConfigItem,\n  fieldProps,\n}: AutoFormInputComponentProps) {\n  return (\n    <div>\n      <FormItem>\n        <div className=\"flex items-center gap-3\">\n          <FormControl>\n            <Switch\n              checked={field.value}\n              onCheckedChange={field.onChange}\n              {...fieldProps}\n            />\n          </FormControl>\n          <AutoFormLabel\n            label={fieldConfigItem?.label || label}\n            isRequired={isRequired}\n          />\n        </div>\n      </FormItem>\n      <AutoFormTooltip fieldConfigItem={fieldConfigItem} />\n    </div>\n  );\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "fields/radio-group.tsx",
      "target": "src/components/ui/auto-form/fields/radio-group.tsx",
      "content": "import {\n  FormControl,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from \"@/components/ui/form\";\nimport { RadioGroup, RadioGroupItem } from \"@/components/ui/radio-group\";\nimport * as z from \"zod\";\nimport AutoFormLabel from \"../common/label\";\nimport AutoFormTooltip from \"../common/tooltip\";\nimport { AutoFormInputComponentProps } from \"../types\";\nimport { getBaseSchema } from \"../utils\";\n\nexport default function AutoFormRadioGroup({\n  label,\n  isRequired,\n  field,\n  zodItem,\n  fieldProps,\n  fieldConfigItem,\n}: AutoFormInputComponentProps) {\n  const baseValues = (getBaseSchema(zodItem) as unknown as z.ZodEnum<any>)._def\n    .values;\n\n  let values: string[] = [];\n  if (!Array.isArray(baseValues)) {\n    values = Object.entries(baseValues).map((item) => item[0]);\n  } else {\n    values = baseValues;\n  }\n\n  return (\n    <div>\n      <FormItem>\n        <AutoFormLabel\n          label={fieldConfigItem?.label || label}\n          isRequired={isRequired}\n        />\n        <FormControl>\n          <RadioGroup\n            onValueChange={field.onChange}\n            defaultValue={field.value}\n            {...fieldProps}\n          >\n            {values?.map((value: any) => (\n              <FormItem\n                key={value}\n                className=\"mb-2 flex items-center gap-3 space-y-0\"\n              >\n                <FormControl>\n                  <RadioGroupItem value={value} />\n                </FormControl>\n                <FormLabel className=\"font-normal\">{value}</FormLabel>\n              </FormItem>\n            ))}\n          </RadioGroup>\n        </FormControl>\n        <FormMessage />\n      </FormItem>\n      <AutoFormTooltip fieldConfigItem={fieldConfigItem} />\n    </div>\n  );\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "fields/object.tsx",
      "target": "src/components/ui/auto-form/fields/object.tsx",
      "content": "import {\n  Accordion,\n  AccordionContent,\n  AccordionItem,\n  AccordionTrigger,\n} from \"@/components/ui/accordion\";\nimport { FormField } from \"@/components/ui/form\";\nimport { useForm, useFormContext } from \"react-hook-form\";\nimport * as z from \"zod\";\nimport { DEFAULT_ZOD_HANDLERS, INPUT_COMPONENTS } from \"../config\";\nimport { Dependency, FieldConfig, FieldConfigItem } from \"../types\";\nimport {\n  beautifyObjectName,\n  getBaseSchema,\n  getBaseType,\n  sortFieldsByOrder,\n  zodToHtmlInputProps,\n} from \"../utils\";\nimport AutoFormArray from \"./array\";\nimport resolveDependencies from \"../dependencies\";\n\nfunction DefaultParent({ children }: { children: React.ReactNode }) {\n  return <>{children}</>;\n}\n\nexport default function AutoFormObject<\n  SchemaType extends z.ZodObject<any, any>,\n>({\n  schema,\n  form,\n  fieldConfig,\n  path = [],\n  dependencies = [],\n}: {\n  schema: SchemaType | z.ZodEffects<SchemaType>;\n  form: ReturnType<typeof useForm>;\n  fieldConfig?: FieldConfig<z.infer<SchemaType>>;\n  path?: string[];\n  dependencies?: Dependency<z.infer<SchemaType>>[];\n}) {\n  const { watch } = useFormContext(); // Use useFormContext to access the watch function\n\n  if (!schema) {\n    return null;\n  }\n  const { shape } = getBaseSchema<SchemaType>(schema) || {};\n\n  if (!shape) {\n    return null;\n  }\n\n  const handleIfZodNumber = (item: z.ZodAny) => {\n    const isZodNumber = (item as any)._def.typeName === \"ZodNumber\";\n    const isInnerZodNumber =\n      (item._def as any).innerType?._def?.typeName === \"ZodNumber\";\n\n    if (isZodNumber) {\n      (item as any)._def.coerce = true;\n    } else if (isInnerZodNumber) {\n      (item._def as any).innerType._def.coerce = true;\n    }\n\n    return item;\n  };\n\n  const sortedFieldKeys = sortFieldsByOrder(fieldConfig, Object.keys(shape));\n\n  return (\n    <Accordion type=\"multiple\" className=\"space-y-5 border-none\">\n      {sortedFieldKeys.map((name) => {\n        let item = shape[name] as z.ZodAny;\n        item = handleIfZodNumber(item) as z.ZodAny;\n        const zodBaseType = getBaseType(item);\n        const itemName = item._def.description ?? beautifyObjectName(name);\n        const key = [...path, name].join(\".\");\n\n        const {\n          isHidden,\n          isDisabled,\n          isRequired: isRequiredByDependency,\n          overrideOptions,\n        } = resolveDependencies(dependencies, name, watch);\n        if (isHidden) {\n          return null;\n        }\n\n        if (zodBaseType === \"ZodObject\") {\n          return (\n            <AccordionItem value={name} key={key} className=\"border-none\">\n              <AccordionTrigger>{itemName}</AccordionTrigger>\n              <AccordionContent className=\"p-2\">\n                <AutoFormObject\n                  schema={item as unknown as z.ZodObject<any, any>}\n                  form={form}\n                  fieldConfig={\n                    (fieldConfig?.[name] ?? {}) as FieldConfig<\n                      z.infer<typeof item>\n                    >\n                  }\n                  path={[...path, name]}\n                />\n              </AccordionContent>\n            </AccordionItem>\n          );\n        }\n        if (zodBaseType === \"ZodArray\") {\n          return (\n            <AutoFormArray\n              key={key}\n              name={name}\n              item={item as unknown as z.ZodArray<any>}\n              form={form}\n              fieldConfig={fieldConfig?.[name] ?? {}}\n              path={[...path, name]}\n            />\n          );\n        }\n\n        const fieldConfigItem: FieldConfigItem = fieldConfig?.[name] ?? {};\n        const zodInputProps = zodToHtmlInputProps(item);\n        const isRequired =\n          isRequiredByDependency ||\n          zodInputProps.required ||\n          fieldConfigItem.inputProps?.required ||\n          false;\n\n        if (overrideOptions) {\n          item = z.enum(overrideOptions) as unknown as z.ZodAny;\n        }\n\n        return (\n          <FormField\n            control={form.control}\n            name={key}\n            key={key}\n            render={({ field }) => {\n              const inputType =\n                fieldConfigItem.fieldType ??\n                DEFAULT_ZOD_HANDLERS[zodBaseType] ??\n                \"fallback\";\n\n              const InputComponent =\n                typeof inputType === \"function\"\n                  ? inputType\n                  : INPUT_COMPONENTS[inputType];\n\n              const ParentElement =\n                fieldConfigItem.renderParent ?? DefaultParent;\n\n              const defaultValue = fieldConfigItem.inputProps?.defaultValue;\n              const value = field.value ?? defaultValue ?? \"\";\n\n              const fieldProps = {\n                ...zodToHtmlInputProps(item),\n                ...field,\n                ...fieldConfigItem.inputProps,\n                disabled: fieldConfigItem.inputProps?.disabled || isDisabled,\n                ref: undefined,\n                value: value,\n              };\n\n              if (InputComponent === undefined) {\n                return <></>;\n              }\n\n              return (\n                <ParentElement key={`${key}.parent`}>\n                  <InputComponent\n                    zodInputProps={zodInputProps}\n                    field={field}\n                    fieldConfigItem={fieldConfigItem}\n                    label={itemName}\n                    isRequired={isRequired}\n                    zodItem={item}\n                    fieldProps={fieldProps}\n                    className={fieldProps.className}\n                  />\n                </ParentElement>\n              );\n            }}\n          />\n        );\n      })}\n    </Accordion>\n  );\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "fields/number.tsx",
      "target": "src/components/ui/auto-form/fields/number.tsx",
      "content": "import { FormControl, FormItem, FormMessage } from \"@/components/ui/form\";\nimport { Input } from \"@/components/ui/input\";\nimport AutoFormLabel from \"../common/label\";\nimport AutoFormTooltip from \"../common/tooltip\";\nimport { AutoFormInputComponentProps } from \"../types\";\n\nexport default function AutoFormNumber({\n  label,\n  isRequired,\n  fieldConfigItem,\n  fieldProps,\n}: AutoFormInputComponentProps) {\n  const { showLabel: _showLabel, ...fieldPropsWithoutShowLabel } = fieldProps;\n  const showLabel = _showLabel === undefined ? true : _showLabel;\n\n  return (\n    <FormItem>\n      {showLabel && (\n        <AutoFormLabel\n          label={fieldConfigItem?.label || label}\n          isRequired={isRequired}\n        />\n      )}\n      <FormControl>\n        <Input type=\"number\" {...fieldPropsWithoutShowLabel} />\n      </FormControl>\n      <AutoFormTooltip fieldConfigItem={fieldConfigItem} />\n      <FormMessage />\n    </FormItem>\n  );\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "fields/input.tsx",
      "target": "src/components/ui/auto-form/fields/input.tsx",
      "content": "import { FormControl, FormItem, FormMessage } from \"@/components/ui/form\";\nimport { Input } from \"@/components/ui/input\";\nimport AutoFormLabel from \"../common/label\";\nimport AutoFormTooltip from \"../common/tooltip\";\nimport { AutoFormInputComponentProps } from \"../types\";\n\nexport default function AutoFormInput({\n  label,\n  isRequired,\n  fieldConfigItem,\n  fieldProps,\n}: AutoFormInputComponentProps) {\n  const { showLabel: _showLabel, ...fieldPropsWithoutShowLabel } = fieldProps;\n  const showLabel = _showLabel === undefined ? true : _showLabel;\n  const type = fieldProps.type || \"text\";\n\n  return (\n    <div className=\"flex flex-row  items-center space-x-2\">\n      <FormItem className=\"flex w-full flex-col justify-start\">\n        {showLabel && (\n          <AutoFormLabel\n            label={fieldConfigItem?.label || label}\n            isRequired={isRequired}\n          />\n        )}\n        <FormControl>\n          <Input type={type} {...fieldPropsWithoutShowLabel} />\n        </FormControl>\n        <AutoFormTooltip fieldConfigItem={fieldConfigItem} />\n        <FormMessage />\n      </FormItem>\n    </div>\n  );\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "fields/file.tsx",
      "target": "src/components/ui/auto-form/fields/file.tsx",
      "content": "import { FormControl, FormItem, FormMessage } from \"@/components/ui/form\";\nimport { Input } from \"@/components/ui/input\";\nimport { Trash2 } from \"lucide-react\";\nimport { ChangeEvent, useState } from \"react\";\nimport AutoFormLabel from \"../common/label\";\nimport AutoFormTooltip from \"../common/tooltip\";\nimport { AutoFormInputComponentProps } from \"../types\";\nexport default function AutoFormFile({\n  label,\n  isRequired,\n  fieldConfigItem,\n  fieldProps,\n  field,\n}: AutoFormInputComponentProps) {\n  const { showLabel: _showLabel, ...fieldPropsWithoutShowLabel } = fieldProps;\n  const showLabel = _showLabel === undefined ? true : _showLabel;\n  const [file, setFile] = useState<string | null>(null);\n  const [fileName, setFileName] = useState<string | null>(null);\n  const handleFileChange = (e: ChangeEvent<HTMLInputElement>) => {\n    const file = e.target.files?.[0];\n\n    if (file) {\n      const reader = new FileReader();\n      reader.onloadend = () => {\n        setFile(reader.result as string);\n        setFileName(file.name);\n        field.onChange(reader.result as string);\n      };\n      reader.readAsDataURL(file);\n    }\n  };\n\n  const handleRemoveClick = () => {\n    setFile(null);\n  };\n\n  return (\n    <FormItem>\n      {showLabel && (\n        <AutoFormLabel\n          label={fieldConfigItem?.label || label}\n          isRequired={isRequired}\n        />\n      )}\n      {!file && (\n        <FormControl>\n          <Input\n            type=\"file\"\n            {...fieldPropsWithoutShowLabel}\n            onChange={handleFileChange}\n            value={\"\"}\n          />\n        </FormControl>\n      )}\n      {file && (\n        <div className=\"flex h-[40px] w-full flex-row items-center justify-between space-x-2 rounded-sm border p-2 text-black focus-visible:ring-0 focus-visible:ring-offset-0 dark:bg-white dark:text-black dark:focus-visible:ring-0 dark:focus-visible:ring-offset-0\">\n          <p>{fileName}</p>\n          <button onClick={handleRemoveClick} aria-label=\"Remove image\">\n            <Trash2 size={16} />\n          </button>\n        </div>\n      )}\n      <AutoFormTooltip fieldConfigItem={fieldConfigItem} />\n      <FormMessage />\n    </FormItem>\n  );\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "fields/enum.tsx",
      "target": "src/components/ui/auto-form/fields/enum.tsx",
      "content": "import { FormControl, FormItem, FormMessage } from \"@/components/ui/form\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport * as z from \"zod\";\nimport AutoFormLabel from \"../common/label\";\nimport AutoFormTooltip from \"../common/tooltip\";\nimport { AutoFormInputComponentProps } from \"../types\";\nimport { getBaseSchema } from \"../utils\";\n\nexport default function AutoFormEnum({\n  label,\n  isRequired,\n  field,\n  fieldConfigItem,\n  zodItem,\n  fieldProps,\n}: AutoFormInputComponentProps) {\n  const baseValues = (getBaseSchema(zodItem) as unknown as z.ZodEnum<any>)._def\n    .values;\n\n  let values: [string, string][] = [];\n  if (!Array.isArray(baseValues)) {\n    values = Object.entries(baseValues);\n  } else {\n    values = baseValues.map((value) => [value, value]);\n  }\n\n  function findItem(value: any) {\n    return values.find((item) => item[0] === value);\n  }\n\n  return (\n    <FormItem>\n      <AutoFormLabel\n        label={fieldConfigItem?.label || label}\n        isRequired={isRequired}\n      />\n      <FormControl>\n        <Select\n          onValueChange={field.onChange}\n          defaultValue={field.value}\n          {...fieldProps}\n        >\n          <SelectTrigger className={fieldProps.className}>\n            <SelectValue placeholder={fieldConfigItem.inputProps?.placeholder}>\n              {field.value ? findItem(field.value)?.[1] : \"Select an option\"}\n            </SelectValue>\n          </SelectTrigger>\n          <SelectContent>\n            {values.map(([value, label]) => (\n              <SelectItem value={label} key={value}>\n                {label}\n              </SelectItem>\n            ))}\n          </SelectContent>\n        </Select>\n      </FormControl>\n      <AutoFormTooltip fieldConfigItem={fieldConfigItem} />\n      <FormMessage />\n    </FormItem>\n  );\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "fields/date.tsx",
      "target": "src/components/ui/auto-form/fields/date.tsx",
      "content": "import { DatePicker } from \"@/components/ui/date-picker\";\nimport { FormControl, FormItem, FormMessage } from \"@/components/ui/form\";\nimport AutoFormLabel from \"../common/label\";\nimport AutoFormTooltip from \"../common/tooltip\";\nimport { AutoFormInputComponentProps } from \"../types\";\n\nexport default function AutoFormDate({\n  label,\n  isRequired,\n  field,\n  fieldConfigItem,\n  fieldProps,\n}: AutoFormInputComponentProps) {\n  return (\n    <FormItem>\n      <AutoFormLabel\n        label={fieldConfigItem?.label || label}\n        isRequired={isRequired}\n      />\n      <FormControl>\n        <DatePicker\n          date={field.value}\n          setDate={field.onChange}\n          {...fieldProps}\n        />\n      </FormControl>\n      <AutoFormTooltip fieldConfigItem={fieldConfigItem} />\n\n      <FormMessage />\n    </FormItem>\n  );\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "fields/checkbox.tsx",
      "target": "src/components/ui/auto-form/fields/checkbox.tsx",
      "content": "import { Checkbox } from \"@/components/ui/checkbox\";\nimport { FormControl, FormItem } from \"@/components/ui/form\";\nimport AutoFormTooltip from \"../common/tooltip\";\nimport { AutoFormInputComponentProps } from \"../types\";\nimport AutoFormLabel from \"../common/label\";\n\nexport default function AutoFormCheckbox({\n  label,\n  isRequired,\n  field,\n  fieldConfigItem,\n  fieldProps,\n}: AutoFormInputComponentProps) {\n  return (\n    <div>\n      <FormItem>\n        <div className=\"mb-3 flex items-center gap-3\">\n          <FormControl>\n            <Checkbox\n              checked={field.value}\n              onCheckedChange={field.onChange}\n              {...fieldProps}\n            />\n          </FormControl>\n          <AutoFormLabel\n            label={fieldConfigItem?.label || label}\n            isRequired={isRequired}\n          />\n        </div>\n      </FormItem>\n      <AutoFormTooltip fieldConfigItem={fieldConfigItem} />\n    </div>\n  );\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "fields/array.tsx",
      "target": "src/components/ui/auto-form/fields/array.tsx",
      "content": "import {\n  AccordionContent,\n  AccordionItem,\n  AccordionTrigger,\n} from \"@/components/ui/accordion\";\nimport { Button } from \"@/components/ui/button\";\nimport { Separator } from \"@/components/ui/separator\";\nimport { Plus, Trash } from \"lucide-react\";\nimport { useFieldArray, useForm } from \"react-hook-form\";\nimport * as z from \"zod\";\nimport { beautifyObjectName } from \"../utils\";\nimport AutoFormObject from \"./object\";\n\nfunction isZodArray(\n  item: z.ZodArray<any> | z.ZodDefault<any>,\n): item is z.ZodArray<any> {\n  return item instanceof z.ZodArray;\n}\n\nfunction isZodDefault(\n  item: z.ZodArray<any> | z.ZodDefault<any>,\n): item is z.ZodDefault<any> {\n  return item instanceof z.ZodDefault;\n}\n\nexport default function AutoFormArray({\n  name,\n  item,\n  form,\n  path = [],\n  fieldConfig,\n}: {\n  name: string;\n  item: z.ZodArray<any> | z.ZodDefault<any>;\n  form: ReturnType<typeof useForm>;\n  path?: string[];\n  fieldConfig?: any;\n}) {\n  const { fields, append, remove } = useFieldArray({\n    control: form.control,\n    name,\n  });\n  const title = item._def.description ?? beautifyObjectName(name);\n\n  const itemDefType = isZodArray(item)\n    ? item._def.type\n    : isZodDefault(item)\n    ? item._def.innerType._def.type\n    : null;\n\n  return (\n    <AccordionItem value={name} className=\"border-none\">\n      <AccordionTrigger>{title}</AccordionTrigger>\n      <AccordionContent>\n        {fields.map((_field, index) => {\n          const key = _field.id;\n          return (\n            <div className=\"mt-4 flex flex-col\" key={`${key}`}>\n              <AutoFormObject\n                schema={itemDefType as z.ZodObject<any, any>}\n                form={form}\n                fieldConfig={fieldConfig}\n                path={[...path, index.toString()]}\n              />\n              <div className=\"my-4 flex justify-end\">\n                <Button\n                  variant=\"secondary\"\n                  size=\"icon\"\n                  type=\"button\"\n                  className=\"hover:bg-zinc-300 hover:text-black focus:ring-0 focus:ring-offset-0 focus-visible:ring-0 focus-visible:ring-offset-0 dark:bg-white dark:text-black dark:hover:bg-zinc-300 dark:hover:text-black dark:hover:ring-0 dark:hover:ring-offset-0 dark:focus-visible:ring-0 dark:focus-visible:ring-offset-0\"\n                  onClick={() => remove(index)}\n                >\n                  <Trash className=\"size-4 \" />\n                </Button>\n              </div>\n\n              <Separator />\n            </div>\n          );\n        })}\n        <Button\n          type=\"button\"\n          variant=\"secondary\"\n          onClick={() => append({})}\n          className=\"mt-4 flex items-center\"\n        >\n          <Plus className=\"mr-2\" size={16} />\n          Add\n        </Button>\n      </AccordionContent>\n    </AccordionItem>\n  );\n}\n",
      "type": "registry:ui"
    },
    {
      "path": "common/tooltip.tsx",
      "target": "src/components/ui/auto-form/common/tooltip.tsx",
      "content": "function AutoFormTooltip({ fieldConfigItem }: { fieldConfigItem: any }) {\n  return (\n    <>\n      {fieldConfigItem?.description && (\n        <p className=\"text-sm text-gray-500 dark:text-white\">\n          {fieldConfigItem.description}\n        </p>\n      )}\n    </>\n  );\n}\n\nexport default AutoFormTooltip;\n",
      "type": "registry:ui"
    },
    {
      "path": "common/label.tsx",
      "target": "src/components/ui/auto-form/common/label.tsx",
      "content": "import { FormLabel } from \"@/components/ui/form\";\nimport { cn } from \"@/lib/utils\";\n\nfunction AutoFormLabel({\n  label,\n  isRequired,\n  className,\n}: {\n  label: string;\n  isRequired: boolean;\n  className?: string;\n}) {\n  return (\n    <>\n      <FormLabel className={cn(className)}>\n        {label}\n        {isRequired && <span className=\"text-destructive\"> *</span>}\n      </FormLabel>\n    </>\n  );\n}\n\nexport default AutoFormLabel;\n",
      "type": "registry:ui"
    },
    {
      "path": "date-picker.tsx",
      "content": "\"use client\";\nimport { format } from \"date-fns\";\nimport { Calendar as CalendarIcon } from \"lucide-react\";\n\nimport { cn } from \"@/lib/utils\";\nimport { Button } from \"@/components/ui/button\";\nimport { Calendar } from \"@/components/ui/calendar\";\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\";\nimport { forwardRef } from \"react\";\n\nexport const DatePicker = forwardRef<\n  HTMLDivElement,\n  {\n    date?: Date;\n    setDate: (date?: Date) => void;\n  }\n>(function DatePickerCmp({ date, setDate }, ref) {\n  return (\n    <Popover>\n      <PopoverTrigger asChild>\n        <Button\n          variant={\"outline\"}\n          className={cn(\n            \"w-full justify-start text-left font-normal\",\n            !date && \"text-muted-foreground\",\n          )}\n        >\n          <CalendarIcon className=\"mr-2 h-4 w-4\" />\n          {date ? format(date, \"PPP\") : <span>Pick a date</span>}\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent className=\"w-auto p-0\" ref={ref}>\n        <Calendar\n          mode=\"single\"\n          selected={date}\n          onSelect={setDate}\n          initialFocus\n        />\n      </PopoverContent>\n    </Popover>\n  );\n});\n",
      "type": "registry:ui"
    }
  ]
}